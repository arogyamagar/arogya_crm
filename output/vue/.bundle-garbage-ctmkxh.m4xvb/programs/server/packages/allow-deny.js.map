{"version":3,"sources":["meteor://ðŸ’»app/packages/allow-deny/allow-deny.js"],"names":["hasOwn","Object","prototype","hasOwnProperty","AllowDeny","CollectionPrototype","allow","options","addValidator","deny","_defineMutationMethods","self","_restricted","_insecure","undefined","_validators","insert","update","remove","upsert","fetch","fetchAllFields","_name","_prefix","_connection","Meteor","server","isClient","m","forEach","method","methodName","useExisting","handlerPropName","check","arguments","Match","Any","args","Array","from","generatedId","call","_makeNewID","isSimulation","_id","_collection","apply","throwIfSelectorIsNotId","length","Error","validatedMethodName","charAt","toUpperCase","slice","unshift","userId","push","_isInsecure","e","name","toString","methods","_updateFetch","fields","union","create","add","names","keys","Package","insecure","_validatedInsert","doc","some","validator","docToValidate","every","_validatedUpdate","selector","mutator","assign","LocalCollection","_selectorIsIdPerhapsAsObject","noReplaceError","mutatorKeys","modifiedFields","op","params","ALLOWED_UPDATE_OPERATIONS","field","indexOf","substring","findOptions","transform","fieldName","findOne","factoriedDoc","transformDoc","_forbidReplace","$inc","$set","$unset","$addToSet","$pop","$pullAll","$pull","$pushAll","$push","$bit","_validatedRemove","_callMutatorMethod","callback","alreadyInSimulation","err","_debug","firstArgIsSelector","mutatorMethodName","returnStubValue","ret","EJSON","clone","collection","allowOrDeny","validKeysRegEx","key","test","Function","_transform","wrapTransform","CurrentInvocation","DDP","_CurrentMethodInvocation","_CurrentInvocation","enclosing","get"],"mappings":"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","file":"/packages/allow-deny.js","sourcesContent":["///\n/// Remote methods and access control.\n///\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// Restrict default mutators on collection. allow() and deny() take the\n// same options:\n//\n// options.insert {Function(userId, doc)}\n//   return true to allow/deny adding this document\n//\n// options.update {Function(userId, docs, fields, modifier)}\n//   return true to allow/deny updating these documents.\n//   `fields` is passed as an array of fields that are to be modified\n//\n// options.remove {Function(userId, docs)}\n//   return true to allow/deny removing these documents\n//\n// options.fetch {Array}\n//   Fields to fetch for these validators. If any call to allow or deny\n//   does not have this option then all fields are loaded.\n//\n// allow and deny can be called multiple times. The validators are\n// evaluated as follows:\n// - If neither deny() nor allow() has been called on the collection,\n//   then the request is allowed if and only if the \"insecure\" smart\n//   package is in use.\n// - Otherwise, if any deny() function returns true, the request is denied.\n// - Otherwise, if any allow() function returns true, the request is allowed.\n// - Otherwise, the request is denied.\n//\n// Meteor may call your deny() and allow() functions in any order, and may not\n// call all of them if it is able to make a decision without calling them all\n// (so don't include side effects).\n\nAllowDeny = {\n  CollectionPrototype: {}\n};\n\n// In the `mongo` package, we will extend Mongo.Collection.prototype with these\n// methods\nconst CollectionPrototype = AllowDeny.CollectionPrototype;\n\n/**\n * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\n * @locus Server\n * @method allow\n * @memberOf Mongo.Collection\n * @instance\n * @param {Object} options\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */\nCollectionPrototype.allow = function(options) {\n  addValidator(this, 'allow', options);\n};\n\n/**\n * @summary Override `allow` rules.\n * @locus Server\n * @method deny\n * @memberOf Mongo.Collection\n * @instance\n * @param {Object} options\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */\nCollectionPrototype.deny = function(options) {\n  addValidator(this, 'deny', options);\n};\n\nCollectionPrototype._defineMutationMethods = function(options) {\n  const self = this;\n  options = options || {};\n\n  // set to true once we call any allow or deny methods. If true, use\n  // allow/deny semantics. If false, use insecure mode semantics.\n  self._restricted = false;\n\n  // Insecure mode (default to allowing writes). Defaults to 'undefined' which\n  // means insecure iff the insecure package is loaded. This property can be\n  // overriden by tests or packages wishing to change insecure mode behavior of\n  // their collections.\n  self._insecure = undefined;\n\n  self._validators = {\n    insert: {allow: [], deny: []},\n    update: {allow: [], deny: []},\n    remove: {allow: [], deny: []},\n    upsert: {allow: [], deny: []}, // dummy arrays; can't set these!\n    fetch: [],\n    fetchAllFields: false\n  };\n\n  if (!self._name)\n    return; // anonymous collection\n\n  // XXX Think about method namespacing. Maybe methods should be\n  // \"Meteor:Mongo:insert/NAME\"?\n  self._prefix = '/' + self._name + '/';\n\n  // Mutation Methods\n  // Minimongo on the server gets no stubs; instead, by default\n  // it wait()s until its result is ready, yielding.\n  // This matches the behavior of macromongo on the server better.\n  // XXX see #MeteorServerNull\n  if (self._connection && (self._connection === Meteor.server || Meteor.isClient)) {\n    const m = {};\n\n    ['insert', 'update', 'remove'].forEach((method) => {\n      const methodName = self._prefix + method;\n\n      if (options.useExisting) {\n        const handlerPropName = Meteor.isClient ? '_methodHandlers' : 'method_handlers';\n        // Do not try to create additional methods if this has already been called.\n        // (Otherwise the .methods() call below will throw an error.)\n        if (self._connection[handlerPropName] &&\n          typeof self._connection[handlerPropName][methodName] === 'function') return;\n      }\n\n      m[methodName] = function (/* ... */) {\n        // All the methods do their own validation, instead of using check().\n        check(arguments, [Match.Any]);\n        const args = Array.from(arguments);\n        try {\n          // For an insert, if the client didn't specify an _id, generate one\n          // now; because this uses DDP.randomStream, it will be consistent with\n          // what the client generated. We generate it now rather than later so\n          // that if (eg) an allow/deny rule does an insert to the same\n          // collection (not that it really should), the generated _id will\n          // still be the first use of the stream and will be consistent.\n          //\n          // However, we don't actually stick the _id onto the document yet,\n          // because we want allow/deny rules to be able to differentiate\n          // between arbitrary client-specified _id fields and merely\n          // client-controlled-via-randomSeed fields.\n          let generatedId = null;\n          if (method === \"insert\" && !hasOwn.call(args[0], '_id')) {\n            generatedId = self._makeNewID();\n          }\n\n          if (this.isSimulation) {\n            // In a client simulation, you can do any mutation (even with a\n            // complex selector).\n            if (generatedId !== null)\n              args[0]._id = generatedId;\n            return self._collection[method].apply(\n              self._collection, args);\n          }\n\n          // This is the server receiving a method call from the client.\n\n          // We don't allow arbitrary selectors in mutations from the client: only\n          // single-ID selectors.\n          if (method !== 'insert')\n            throwIfSelectorIsNotId(args[0], method);\n\n          if (self._restricted) {\n            // short circuit if there is no way it will pass.\n            if (self._validators[method].allow.length === 0) {\n              throw new Meteor.Error(\n                403, \"Access denied. No allow validators set on restricted \" +\n                  \"collection for method '\" + method + \"'.\");\n            }\n\n            const validatedMethodName =\n                  '_validated' + method.charAt(0).toUpperCase() + method.slice(1);\n            args.unshift(this.userId);\n            method === 'insert' && args.push(generatedId);\n            return self[validatedMethodName].apply(self, args);\n          } else if (self._isInsecure()) {\n            if (generatedId !== null)\n              args[0]._id = generatedId;\n            // In insecure mode, allow any mutation (with a simple selector).\n            // XXX This is kind of bogus.  Instead of blindly passing whatever\n            //     we get from the network to this function, we should actually\n            //     know the correct arguments for the function and pass just\n            //     them.  For example, if you have an extraneous extra null\n            //     argument and this is Mongo on the server, the .wrapAsync'd\n            //     functions like update will get confused and pass the\n            //     \"fut.resolver()\" in the wrong slot, where _update will never\n            //     invoke it. Bam, broken DDP connection.  Probably should just\n            //     take this whole method and write it three times, invoking\n            //     helpers for the common code.\n            return self._collection[method].apply(self._collection, args);\n          } else {\n            // In secure mode, if we haven't called allow or deny, then nothing\n            // is permitted.\n            throw new Meteor.Error(403, \"Access denied\");\n          }\n        } catch (e) {\n          if (\n            e.name === 'MongoError' ||\n            // for old versions of MongoDB (probably not necessary but it's here just in case)\n            e.name === 'BulkWriteError' ||\n            // for newer versions of MongoDB (https://docs.mongodb.com/drivers/node/current/whats-new/#bulkwriteerror---mongobulkwriteerror)\n            e.name === 'MongoBulkWriteError' ||\n            e.name === 'MinimongoError'\n          ) {\n            throw new Meteor.Error(409, e.toString());\n          } else {\n            throw e;\n          }\n        }\n      };\n    });\n\n    self._connection.methods(m);\n  }\n};\n\nCollectionPrototype._updateFetch = function (fields) {\n  const self = this;\n\n  if (!self._validators.fetchAllFields) {\n    if (fields) {\n      const union = Object.create(null);\n      const add = names => names && names.forEach(name => union[name] = 1);\n      add(self._validators.fetch);\n      add(fields);\n      self._validators.fetch = Object.keys(union);\n    } else {\n      self._validators.fetchAllFields = true;\n      // clear fetch just to make sure we don't accidentally read it\n      self._validators.fetch = null;\n    }\n  }\n};\n\nCollectionPrototype._isInsecure = function () {\n  const self = this;\n  if (self._insecure === undefined)\n    return !!Package.insecure;\n  return self._insecure;\n};\n\nCollectionPrototype._validatedInsert = function (userId, doc,\n                                                         generatedId) {\n  const self = this;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (self._validators.insert.deny.some((validator) => {\n    return validator(userId, docToValidate(validator, doc, generatedId));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (self._validators.insert.allow.every((validator) => {\n    return !validator(userId, docToValidate(validator, doc, generatedId));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  // If we generated an ID above, insert it now: after the validation, but\n  // before actually inserting.\n  if (generatedId !== null)\n    doc._id = generatedId;\n\n  self._collection.insert.call(self._collection, doc);\n};\n\n// Simulate a mongo `update` operation while validating that the access\n// control rules set by calls to `allow/deny` are satisfied. If all\n// pass, rewrite the mongo operation to use $in to set the list of\n// document ids to change ##ValidatedChange\nCollectionPrototype._validatedUpdate = function(\n    userId, selector, mutator, options) {\n  const self = this;\n\n  check(mutator, Object);\n\n  options = Object.assign(Object.create(null), options);\n\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector))\n    throw new Error(\"validated update should be of a single ID\");\n\n  // We don't support upserts because they don't fit nicely into allow/deny\n  // rules.\n  if (options.upsert)\n    throw new Meteor.Error(403, \"Access denied. Upserts not \" +\n                           \"allowed in a restricted collection.\");\n\n  const noReplaceError = \"Access denied. In a restricted collection you can only\" +\n        \" update documents, not replace them. Use a Mongo update operator, such \" +\n        \"as '$set'.\";\n\n  const mutatorKeys = Object.keys(mutator);\n\n  // compute modified fields\n  const modifiedFields = {};\n\n  if (mutatorKeys.length === 0) {\n    throw new Meteor.Error(403, noReplaceError);\n  }\n  mutatorKeys.forEach((op) => {\n    const params = mutator[op];\n    if (op.charAt(0) !== '$') {\n      throw new Meteor.Error(403, noReplaceError);\n    } else if (!hasOwn.call(ALLOWED_UPDATE_OPERATIONS, op)) {\n      throw new Meteor.Error(\n        403, \"Access denied. Operator \" + op + \" not allowed in a restricted collection.\");\n    } else {\n      Object.keys(params).forEach((field) => {\n        // treat dotted fields as if they are replacing their\n        // top-level part\n        if (field.indexOf('.') !== -1)\n          field = field.substring(0, field.indexOf('.'));\n\n        // record the field we are trying to change\n        modifiedFields[field] = true;\n      });\n    }\n  });\n\n  const fields = Object.keys(modifiedFields);\n\n  const findOptions = {transform: null};\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    self._validators.fetch.forEach((fieldName) => {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n\n  const doc = self._collection.findOne(selector, findOptions);\n  if (!doc)  // none satisfied!\n    return 0;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (self._validators.update.deny.some((validator) => {\n    const factoriedDoc = transformDoc(validator, doc);\n    return validator(userId,\n                     factoriedDoc,\n                     fields,\n                     mutator);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (self._validators.update.allow.every((validator) => {\n    const factoriedDoc = transformDoc(validator, doc);\n    return !validator(userId,\n                      factoriedDoc,\n                      fields,\n                      mutator);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  options._forbidReplace = true;\n\n  // Back when we supported arbitrary client-provided selectors, we actually\n  // rewrote the selector to include an _id clause before passing to Mongo to\n  // avoid races, but since selector is guaranteed to already just be an ID, we\n  // don't have to any more.\n\n  return self._collection.update.call(\n    self._collection, selector, mutator, options);\n};\n\n// Only allow these operations in validated updates. Specifically\n// whitelist operations, rather than blacklist, so new complex\n// operations that are added aren't automatically allowed. A complex\n// operation is one that does more than just modify its target\n// field. For now this contains all update operations except '$rename'.\n// http://docs.mongodb.org/manual/reference/operators/#update\nconst ALLOWED_UPDATE_OPERATIONS = {\n  $inc:1, $set:1, $unset:1, $addToSet:1, $pop:1, $pullAll:1, $pull:1,\n  $pushAll:1, $push:1, $bit:1\n};\n\n// Simulate a mongo `remove` operation while validating access control\n// rules. See #ValidatedChange\nCollectionPrototype._validatedRemove = function(userId, selector) {\n  const self = this;\n\n  const findOptions = {transform: null};\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    self._validators.fetch.forEach((fieldName) => {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n\n  const doc = self._collection.findOne(selector, findOptions);\n  if (!doc)\n    return 0;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (self._validators.remove.deny.some((validator) => {\n    return validator(userId, transformDoc(validator, doc));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (self._validators.remove.allow.every((validator) => {\n    return !validator(userId, transformDoc(validator, doc));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  // Back when we supported arbitrary client-provided selectors, we actually\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to\n  // Mongo to avoid races, but since selector is guaranteed to already just be\n  // an ID, we don't have to any more.\n\n  return self._collection.remove.call(self._collection, selector);\n};\n\nCollectionPrototype._callMutatorMethod = function _callMutatorMethod(name, args, callback) {\n  if (Meteor.isClient && !callback && !alreadyInSimulation()) {\n    // Client can't block, so it can't report errors by exception,\n    // only by callback. If they forget the callback, give them a\n    // default one that logs the error, so they aren't totally\n    // baffled if their writes don't work because their database is\n    // down.\n    // Don't give a default callback in simulation, because inside stubs we\n    // want to return the results from the local collection immediately and\n    // not force a callback.\n    callback = function (err) {\n      if (err)\n        Meteor._debug(name + \" failed\", err);\n    };\n  }\n\n  // For two out of three mutator methods, the first argument is a selector\n  const firstArgIsSelector = name === \"update\" || name === \"remove\";\n  if (firstArgIsSelector && !alreadyInSimulation()) {\n    // If we're about to actually send an RPC, we should throw an error if\n    // this is a non-ID selector, because the mutation methods only allow\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)\n    throwIfSelectorIsNotId(args[0], name);\n  }\n\n  const mutatorMethodName = this._prefix + name;\n  return this._connection.apply(\n    mutatorMethodName, args, { returnStubValue: true }, callback);\n}\n\nfunction transformDoc(validator, doc) {\n  if (validator.transform)\n    return validator.transform(doc);\n  return doc;\n}\n\nfunction docToValidate(validator, doc, generatedId) {\n  let ret = doc;\n  if (validator.transform) {\n    ret = EJSON.clone(doc);\n    // If you set a server-side transform on your collection, then you don't get\n    // to tell the difference between \"client specified the ID\" and \"server\n    // generated the ID\", because transforms expect to get _id.  If you want to\n    // do that check, you can do it with a specific\n    // `C.allow({insert: f, transform: null})` validator.\n    if (generatedId !== null) {\n      ret._id = generatedId;\n    }\n    ret = validator.transform(ret);\n  }\n  return ret;\n}\n\nfunction addValidator(collection, allowOrDeny, options) {\n  // validate keys\n  const validKeysRegEx = /^(?:insert|update|remove|fetch|transform)$/;\n  Object.keys(options).forEach((key) => {\n    if (!validKeysRegEx.test(key))\n      throw new Error(allowOrDeny + \": Invalid key: \" + key);\n  });\n\n  collection._restricted = true;\n\n  ['insert', 'update', 'remove'].forEach((name) => {\n    if (hasOwn.call(options, name)) {\n      if (!(options[name] instanceof Function)) {\n        throw new Error(allowOrDeny + \": Value for `\" + name + \"` must be a function\");\n      }\n\n      // If the transform is specified at all (including as 'null') in this\n      // call, then take that; otherwise, take the transform from the\n      // collection.\n      if (options.transform === undefined) {\n        options[name].transform = collection._transform;  // already wrapped\n      } else {\n        options[name].transform = LocalCollection.wrapTransform(\n          options.transform);\n      }\n\n      collection._validators[name][allowOrDeny].push(options[name]);\n    }\n  });\n\n  // Only update the fetch fields if we're passed things that affect\n  // fetching. This way allow({}) and allow({insert: f}) don't result in\n  // setting fetchAllFields\n  if (options.update || options.remove || options.fetch) {\n    if (options.fetch && !(options.fetch instanceof Array)) {\n      throw new Error(allowOrDeny + \": Value for `fetch` must be an array\");\n    }\n    collection._updateFetch(options.fetch);\n  }\n}\n\nfunction throwIfSelectorIsNotId(selector, methodName) {\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n    throw new Meteor.Error(\n      403, \"Not permitted. Untrusted code may only \" + methodName +\n        \" documents by ID.\");\n  }\n};\n\n// Determine if we are in a DDP method simulation\nfunction alreadyInSimulation() {\n  var CurrentInvocation =\n    DDP._CurrentMethodInvocation ||\n    // For backwards compatibility, as explained in this issue:\n    // https://github.com/meteor/meteor/issues/8947\n    DDP._CurrentInvocation;\n\n  const enclosing = CurrentInvocation.get();\n  return enclosing && enclosing.isSimulation;\n}\n"]}