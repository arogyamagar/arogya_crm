{"version":3,"sources":["meteor://ðŸ’»app/packages/routepolicy/main.js","meteor://ðŸ’»app/packages/routepolicy/routepolicy.js"],"names":["module","export","RoutePolicy","RoutePolicyConstructor","link","default","v","constructor","urlPrefixTypes","urlPrefixMatches","urlPrefix","url","startsWith","checkType","type","includes","checkUrlPrefix","existingType","checkForConflictWithStatic","_testManifest","policy","check","manifest","conflict","find","resource","where","WebApp","require","errorMessage","Object","keys","clientPrograms","some","arch","declare","problem","Error","isValidUrl","classify","prefix","urlPrefixesFor","entries","filter","_prefix","_type","map","sort"],"mappings":"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","file":"/packages/routepolicy.js","sourcesContent":["import { default as RoutePolicyConstructor } from './routepolicy';\nexport const RoutePolicy = new RoutePolicyConstructor();\n","// In addition to listing specific files to be cached, the browser\n// application cache manifest allows URLs to be designated as NETWORK\n// (always fetched from the Internet) and FALLBACK (which we use to\n// serve app HTML on arbitrary URLs).\n//\n// The limitation of the manifest file format is that the designations\n// are by prefix only: if \"/foo\" is declared NETWORK then \"/foobar\"\n// will also be treated as a network route.\n//\n// RoutePolicy is a low-level API for declaring the route type of URL prefixes:\n//\n// \"network\": for network routes that should not conflict with static\n// resources.  (For example, if \"/sockjs/\" is a network route, we\n// shouldn't have \"/sockjs/red-sock.jpg\" as a static resource).\n//\n// \"static-online\": for static resources which should not be cached in\n// the app cache.  This is implemented by also adding them to the\n// NETWORK section (as otherwise the browser would receive app HTML\n// for them because of the FALLBACK section), but static-online routes\n// don't need to be checked for conflict with static resources.\n\n\nexport default class RoutePolicy {\n  constructor() {\n    // maps prefix to a type\n    this.urlPrefixTypes = {};\n  }\n\n  urlPrefixMatches(urlPrefix, url) {\n    return url.startsWith(urlPrefix);\n  }\n\n  checkType(type) {\n    if (!['network', 'static-online'].includes(type)) {\n      return 'the route type must be \"network\" or \"static-online\"';\n    }\n    return null;\n  }\n\n  checkUrlPrefix(urlPrefix, type) {\n    if (!urlPrefix.startsWith('/')) {\n      return 'a route URL prefix must begin with a slash';\n    }\n\n    if (urlPrefix === '/') {\n      return 'a route URL prefix cannot be /';\n    }\n\n    const existingType = this.urlPrefixTypes[urlPrefix];\n    if (existingType && existingType !== type) {\n      return `the route URL prefix ${urlPrefix} has already been declared ` +\n        `to be of type ${existingType}`;\n    }\n\n    return null;\n  }\n\n  checkForConflictWithStatic(urlPrefix, type, _testManifest) {\n    if (type === 'static-online') {\n      return null;\n    }\n\n    const policy = this;\n\n    function check(manifest) {\n      const conflict = manifest.find(resource => (\n        resource.type === 'static' &&\n        resource.where === 'client' &&\n        policy.urlPrefixMatches(urlPrefix, resource.url)\n      ));\n\n      if (conflict) {\n        return `static resource ${conflict.url} conflicts with ${type} ` +\n          `route ${urlPrefix}`;\n      }\n\n      return null;\n    };\n\n    if (_testManifest) {\n      return check(_testManifest);\n    }\n\n    const { WebApp } = require(\"meteor/webapp\");\n    let errorMessage = null;\n\n    Object.keys(WebApp.clientPrograms).some(arch => {\n      const { manifest } = WebApp.clientPrograms[arch];\n      return errorMessage = check(manifest);\n    });\n\n    return errorMessage;\n  }\n\n  declare(urlPrefix, type) {\n    const problem =\n      this.checkType(type) ||\n      this.checkUrlPrefix(urlPrefix, type) ||\n      this.checkForConflictWithStatic(urlPrefix, type);\n    if (problem) {\n      throw new Error(problem);\n    }\n    // TODO overlapping prefixes, e.g. /foo/ and /foo/bar/\n    this.urlPrefixTypes[urlPrefix] = type;\n  }\n\n  isValidUrl(url) {\n    return url.startsWith('/');\n  }\n\n  classify(url) {\n    if (!this.isValidUrl(url)) {\n      throw new Error(`url must be a relative URL: ${url}`);\n    }\n\n    const prefix = Object.keys(this.urlPrefixTypes).find(prefix =>\n      this.urlPrefixMatches(prefix, url)\n    );\n\n    return prefix ? this.urlPrefixTypes[prefix] : null;\n  }\n\n  urlPrefixesFor(type) {\n    return Object.entries(this.urlPrefixTypes)\n      .filter(([_prefix, _type]) => _type === type)\n      .map(([_prefix]) => _prefix)\n      .sort();\n  }\n}\n"]}